# Feature 0002: AWS Scalability with Stripe Subscriptions and Auth0 Authentication

## Description
Transform the voice cloning application from a single-instance client-side app into a horizontally scalable, cloud-native SaaS application using AWS infrastructure. Implement Auth0 for user authentication, Stripe for subscription management with 3 pricing tiers (Free, Basic, Premium), session persistence with Redis/ElastiCache, DynamoDB for user profiles and recordings, S3 for favorited audio storage, and deploy on AWS Amplify with load balancing and auto-scaling capabilities. Different subscription tiers will have restricted access to advanced audio configuration features.

## Current Architecture Analysis
- **Session Management**: localStorage-based authentication (15-min timeout, client-side only)
- **Data Storage**: In-memory recordings state, no persistence across sessions
- **Audio Files**: Ephemeral blob URLs from ElevenLabs API, lost on page refresh
- **Deployment**: Local/single-instance Next.js application
- **Authentication**: Simple password check ("vip"), no user accounts
- **Monetization**: No subscription tiers or payment processing
- **Audio Configuration**: All users have access to all audio sliders and controls

## Technical Requirements

### Phase 1: Data Layer - Database Schema and Storage

**Files to create:**
- `app/lib/dynamodb.ts` - DynamoDB client configuration and helper functions
- `app/lib/s3.ts` - S3 client for audio file operations
- `app/lib/redis.ts` - Redis/ElastiCache client for session management
- `app/lib/stripe.ts` - Stripe client for subscription management and webhooks
- `app/lib/auth0.ts` - Auth0 client configuration and token validation
- `app/types/database.ts` - Database entity type definitions
- `app/types/subscription.ts` - Subscription tier type definitions and feature flags
- `.env.local.example` - Template for required environment variables

**Subscription Tiers and Feature Access:**

1. **Free Tier** (default, $0/month)
   - Preset audio configurations only (3-5 presets)
   - Limited to 10 recordings per month
   - Standard voice generation speed
   - No advanced audio effects customization (sliders locked)
   - Cannot save custom presets

2. **Basic Tier** ($9.99/month)
   - Preset audio configurations only (10+ presets)
   - 100 recordings per month
   - Priority voice generation
   - No advanced slider access (presets only)
   - Cannot save custom presets
   - Standard support

3. **Premium Tier** ($29.99/month)
   - Full access to all audio sliders and advanced configurations
   - Unlimited recordings
   - Fastest voice generation priority
   - Custom audio presets (save personal configurations)
   - Advanced audio effects controls unlocked
   - Premium support

**DynamoDB Table Schemas:**

1. **Users Table** (`voice-app-users`)
   - Partition Key: `userId` (string, Auth0 user ID)
   - Attributes: 
     - `email` (string)
     - `auth0Id` (string)
     - `stripeCustomerId` (string)
     - `subscriptionTier` (string: FREE | BASIC | PREMIUM)
     - `subscriptionStatus` (string: active | canceled | past_due | trialing)
     - `recordingsThisMonth` (number)
     - `recordingsResetDate` (timestamp)
     - `createdAt` (timestamp)
     - `lastLogin` (timestamp)
     - `preferences` (JSON)
   - GSI: `stripeCustomerId-index` (for Stripe webhook lookups)
   - GSI: `email-index` (for email lookups)

2. **Sessions Table** (`voice-app-sessions`)
   - Partition Key: `sessionId` (string, UUID)
   - Attributes: `userId`, `auth0Token`, `createdAt`, `expiresAt`, `ipAddress`
   - TTL: `expiresAt` (auto-expire sessions after 15 minutes)

3. **Recordings Table** (`voice-app-recordings`)
   - Partition Key: `userId` (string)
   - Sort Key: `recordingId` (string, timestamp-based)
   - Attributes: `voiceId`, `voiceName`, `text`, `speed`, `s3Key`, `isFavorite`, `createdAt`, `audioConfig`, `presetUsed`
   - GSI: `userId-createdAt-index` (for pagination)
   - LSI: `userId-isFavorite-index` (for favorites filtering)

4. **Subscriptions Table** (`voice-app-subscriptions`)
   - Partition Key: `userId` (string)
   - Sort Key: `subscriptionId` (string, Stripe subscription ID)
   - Attributes: `stripeSubscriptionId`, `stripePriceId`, `tier`, `status`, `currentPeriodStart`, `currentPeriodEnd`, `cancelAtPeriodEnd`, `createdAt`
   - GSI: `stripeSubscriptionId-index` (for webhook processing)

**S3 Bucket Structure:**
- Bucket: `voice-app-audio-{environment}`
- Path format: `{userId}/{recordingId}.mp3`
- Lifecycle policy: Delete non-favorited files after 7 days
- CORS configuration for browser playback

**Redis/ElastiCache Schema:**
- Key format: `session:{sessionId}`
- Value: JSON with `userId`, `auth0Id`, `subscriptionTier`, `createdAt`
- TTL: 900 seconds (15 minutes)

### Phase 2A: Authentication and Authorization Layer

**Files to create:**
- `app/api/auth/callback/route.ts` - Auth0 callback handler
- `app/api/auth/login/route.ts` - Initiate Auth0 login flow
- `app/api/auth/logout/route.ts` - Clear session and redirect to Auth0 logout
- `app/api/auth/session/route.ts` - Validate session and return user info
- `app/lib/auth-middleware.ts` - Reusable session validation and tier checking
- `app/lib/feature-flags.ts` - Subscription tier feature access logic

**Auth0 Configuration:**
- Application Type: Regular Web Application
- Allowed Callback URLs: `https://yourdomain.com/api/auth/callback`
- Allowed Logout URLs: `https://yourdomain.com`
- Grant Types: Authorization Code, Refresh Token
- Store user metadata: `stripeCustomerId`, `subscriptionTier`

**Authentication Flow:**
1. User clicks "Sign In" → redirects to Auth0 Universal Login
2. User authenticates via Auth0 (email/password, social, etc.)
3. Auth0 redirects to `/api/auth/callback` with authorization code
4. Backend exchanges code for Auth0 tokens
5. Backend checks if user exists in DynamoDB (by `auth0Id`)
6. If new user: create user record with FREE tier, create Stripe customer
7. Create session in Redis with user info and subscription tier
8. Set HTTP-only session cookie
9. Redirect to main app

**Feature Access Control Logic:**
```typescript
// app/lib/feature-flags.ts
const tierFeatures = {
  FREE: {
    maxRecordingsPerMonth: 10,
    allowAdvancedAudioControls: false,
    allowCustomPresets: false,
    availablePresets: ['preset1', 'preset2', 'preset3']
  },
  BASIC: {
    maxRecordingsPerMonth: 100,
    allowAdvancedAudioControls: false,
    allowCustomPresets: false,
    availablePresets: ['preset1', ..., 'preset10']
  },
  PREMIUM: {
    maxRecordingsPerMonth: -1, // unlimited
    allowAdvancedAudioControls: true,
    allowCustomPresets: true,
    availablePresets: 'all'
  }
}
```

### Phase 2B: Stripe Integration and Subscription Management

**Files to create:**
- `app/api/stripe/checkout/route.ts` - Create Stripe Checkout session
- `app/api/stripe/portal/route.ts` - Create Stripe Customer Portal session
- `app/api/stripe/webhook/route.ts` - Handle Stripe webhook events
- `app/api/stripe/products/route.ts` - List available subscription tiers
- `app/components/SubscriptionPlans.tsx` - Pricing page UI
- `app/components/SubscriptionStatus.tsx` - Current plan display and upgrade CTA

**Stripe Products Configuration:**
1. **Free Tier** - No Stripe product (default)
2. **Basic Tier** - Price ID: `price_basic_monthly`, $9.99/month
3. **Premium Tier** - Price ID: `price_premium_monthly`, $29.99/month

**Stripe Webhook Events to Handle:**
- `checkout.session.completed` - User completed subscription purchase
  - Update user's `subscriptionTier` and `subscriptionStatus` in DynamoDB
  - Create record in Subscriptions table
- `customer.subscription.updated` - Subscription changed (upgrade/downgrade)
  - Update user's tier and status
- `customer.subscription.deleted` - Subscription canceled
  - Downgrade user to FREE tier
  - Update status to 'canceled'
- `invoice.payment_failed` - Payment failed
  - Update status to 'past_due'
  - Send notification email

**API Endpoints:**

1. `POST /api/stripe/checkout` - Create checkout session
   - Input: `{ priceId: string, tier: 'BASIC' | 'PREMIUM' }`
   - Returns: `{ sessionUrl: string }`
   - Requires authentication

2. `POST /api/stripe/portal` - Create customer portal session
   - Returns: `{ portalUrl: string }`
   - Allows users to manage subscription, payment methods, invoices

3. `POST /api/stripe/webhook` - Handle Stripe webhooks
   - Validates webhook signature
   - Processes subscription lifecycle events
   - Updates DynamoDB user and subscription records

4. `GET /api/stripe/products` - List subscription tiers
   - Returns: `{ plans: [{ tier, priceId, price, features }] }`

### Phase 2C: Backend API Layer

**Files to create:**
- `app/api/recordings/route.ts` - GET (list) and POST (save favorite) endpoints
- `app/api/recordings/[id]/route.ts` - GET (single), DELETE, PATCH (toggle favorite)
- `app/api/user/profile/route.ts` - GET user profile and subscription info
- `app/api/user/usage/route.ts` - GET current month's usage stats

**Files to modify (existing):**
- `app/api/tts/route.ts` - Add session validation, tier-based rate limiting, usage tracking
- `app/api/voices/route.ts` - Add session validation middleware
- `app/api/ivc/route.ts` - Add session validation middleware

**Middleware Implementation:**
- `app/middleware.ts` - Session validation for all protected routes
- Check Redis for session existence
- Return 401 if session invalid/expired
- Refresh session TTL on valid requests
- Attach user info and subscription tier to request context

**Recording Usage Tracking:**
- Before creating TTS: check user's `recordingsThisMonth` vs tier limit
- If at limit (not Premium): return 403 with upgrade message
- Increment `recordingsThisMonth` after successful generation
- Reset counter monthly using scheduled job or on-demand check

**API Endpoints to Create:**

1. `GET /api/user/profile` - Get current user profile
   - Returns: `{ userId, email, subscriptionTier, subscriptionStatus, recordingsThisMonth, maxRecordings, features }`

2. `GET /api/user/usage` - Get usage statistics
   - Returns: `{ recordingsUsed, recordingsLimit, resetDate }`

3. `GET /api/recordings` - List user recordings
   - Query params: `?page=1&limit=20&favoritesOnly=false`
   - Returns paginated recordings from DynamoDB

4. `POST /api/recordings` - Save recording as favorite
   - Input: `{ audioBlob: File, voiceId, voiceName, text, speed, audioConfig, presetUsed }`
   - Uploads to S3, saves metadata to DynamoDB
   - Returns: `{ recordingId, s3Url }`

5. `PATCH /api/recordings/[id]` - Toggle favorite status
   - Updates `isFavorite` flag in DynamoDB

6. `DELETE /api/recordings/[id]` - Delete recording
   - Removes from S3 and DynamoDB

### Phase 2D: Frontend State Management

**Files to modify:**
- `app/hooks/useAuthentication.ts` - Use Auth0 session instead of localStorage
- `app/hooks/useVoiceManagement.ts` - Add recording persistence hooks
- `app/components/AuthGuard.tsx` - Use Auth0 session validation
- `app/components/AudioControls.tsx` - Conditionally render sliders based on subscription tier
- `app/components/VoiceSelectionRoute.tsx` - Show upgrade prompts when limits reached

**Files to create:**
- `app/hooks/useRecordingPersistence.ts` - Hooks for saving/loading recordings from backend
- `app/hooks/useSession.ts` - Session validation and user profile fetching
- `app/hooks/useSubscription.ts` - Subscription status and feature access
- `app/hooks/useUsageTracking.ts` - Track recording usage against limits
- `app/components/RecordingActions.tsx` - UI for save/favorite/delete actions
- `app/components/SubscriptionPlans.tsx` - Pricing page with tier comparison
- `app/components/UpgradePrompt.tsx` - CTA to upgrade when hitting limits
- `app/components/FeatureLockedOverlay.tsx` - Overlay for locked premium features

**Conditional Feature Rendering:**
- Check `subscriptionTier` from user profile
- For FREE/BASIC: hide advanced audio sliders, show "Upgrade to Premium" overlay
- Show preset selector with tier-appropriate presets
- Display usage counter: "X / Y recordings this month"
- Show upgrade CTA when approaching limit

**React Query Integration:**
- Query for user profile on mount
- Query for recordings list with pagination
- Mutations for save/favorite/delete operations
- Optimistic updates for better UX
- Mutation for creating Stripe checkout session

**State Management Changes:**
- Remove in-memory recordings array from `app/page.tsx`
- Fetch recordings from API on mount
- Save recordings to backend when user clicks "Save" button
- Track usage and show upgrade prompt when limit reached
- Disable TTS generation button if at monthly limit (non-Premium)

### Phase 3: AWS Infrastructure Setup

**AWS Services Configuration:**

1. **DynamoDB Tables**
   - Provisioned capacity: On-demand mode for auto-scaling
   - Point-in-time recovery enabled
   - Encryption at rest with AWS-managed keys
   - Create 4 tables: Users, Sessions, Recordings, Subscriptions

2. **ElastiCache for Redis**
   - Instance type: cache.t3.micro (dev), cache.r6g.large (prod)
   - Engine: Redis 7.x
   - Cluster mode disabled (single node for simplicity)
   - Automatic failover enabled in production

3. **S3 Bucket**
   - Versioning disabled (audio files are immutable)
   - Server-side encryption (SSE-S3)
   - Block public access (use pre-signed URLs)
   - Lifecycle rule: transition non-favorited files to Glacier after 7 days, delete after 30 days

4. **AWS Amplify Deployment**
   - Build settings for Next.js
   - Environment variables injection
   - Auto-scaling based on traffic (handled by Amplify)
   - Custom domain with SSL certificate

5. **CloudFront CDN** (via Amplify)
   - Automatic distribution for static assets
   - Edge caching for improved performance
   - HTTPS enforcement

6. **VPC Configuration** (for ElastiCache)
   - Private subnet for Redis cluster
   - Security group allowing access only from Amplify/Lambda

**Infrastructure as Code:**
- `aws/dynamodb-tables.json` - CloudFormation template for all DynamoDB tables
- `aws/s3-bucket.json` - CloudFormation template for S3 bucket with lifecycle policies
- `aws/redis-cluster.json` - CloudFormation template for ElastiCache
- `amplify.yml` - Amplify build configuration

### Phase 4: Security and Environment Configuration

**Files to create/modify:**
- `.env.local.example` - Document all required environment variables
- `app/lib/config.ts` - Centralized configuration management

**Environment Variables Required:**
```
# ElevenLabs (existing)
ELEVENLABS_API_KEY=

# Auth0
AUTH0_DOMAIN=your-tenant.auth0.com
AUTH0_CLIENT_ID=
AUTH0_CLIENT_SECRET=
AUTH0_AUDIENCE=
AUTH0_CALLBACK_URL=https://yourdomain.com/api/auth/callback
AUTH0_LOGOUT_URL=https://yourdomain.com

# Stripe
STRIPE_SECRET_KEY=sk_...
STRIPE_PUBLISHABLE_KEY=pk_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_BASIC_PRICE_ID=price_...
STRIPE_PREMIUM_PRICE_ID=price_...

# AWS Configuration
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=

# DynamoDB
DYNAMODB_USERS_TABLE=voice-app-users
DYNAMODB_SESSIONS_TABLE=voice-app-sessions
DYNAMODB_RECORDINGS_TABLE=voice-app-recordings
DYNAMODB_SUBSCRIPTIONS_TABLE=voice-app-subscriptions

# ElastiCache
REDIS_HOST=
REDIS_PORT=6379

# S3
S3_BUCKET_NAME=voice-app-audio-prod
S3_REGION=us-east-1

# Application
SESSION_DURATION=900000
NEXT_PUBLIC_APP_URL=https://yourdomain.com
```

**Security Enhancements:**
- Auth0 handles user authentication (OAuth 2.0, OIDC)
- Session tokens use HTTP-only cookies (prevent XSS)
- CSRF protection for state-changing operations
- Stripe webhook signature validation
- Rate limiting on API endpoints (tier-based)
- IAM roles with least-privilege access for AWS services
- VPC isolation for Redis cluster

### Phase 5: Migration and Deployment

**Deployment Steps:**
1. Create Auth0 application and configure settings
2. Create Stripe products and price IDs
3. Create AWS resources (DynamoDB, ElastiCache, S3)
4. Configure IAM roles and policies
5. Set environment variables in AWS Amplify
6. Deploy application to Amplify
7. Configure Stripe webhook endpoint
8. Test subscription flows (checkout, upgrade, cancel)
9. Test session persistence across multiple instances
10. Configure custom domain and SSL

**Monitoring and Observability:**
- CloudWatch metrics for DynamoDB read/write capacity
- CloudWatch logs for API route errors
- Redis connection pool monitoring
- S3 storage metrics and lifecycle rule execution
- Stripe dashboard for subscription metrics
- Auth0 logs for authentication events

## Integration Points

**Authentication Flow:**
1. User clicks "Sign In" → `GET /api/auth/login` → redirects to Auth0
2. User authenticates with Auth0
3. Auth0 redirects to `/api/auth/callback?code=...`
4. Backend exchanges code for Auth0 access token
5. Backend retrieves user profile from Auth0
6. Backend looks up or creates user in DynamoDB
7. For new users: create Stripe customer, set tier to FREE
8. Create session in Redis with userId, auth0Id, subscriptionTier
9. Set HTTP-only cookie with sessionId
10. Redirect to main app

**Subscription Flow:**
1. User views pricing page (`/pricing` or embedded modal)
2. User clicks "Subscribe to Basic" or "Subscribe to Premium"
3. Frontend calls `POST /api/stripe/checkout` with priceId
4. Backend creates Stripe Checkout session
5. User redirected to Stripe hosted checkout page
6. User completes payment
7. Stripe webhook `checkout.session.completed` fires
8. Backend updates user's subscriptionTier in DynamoDB to BASIC/PREMIUM
9. Redis session cache invalidated (refresh on next request)
10. User redirected back to app with new features unlocked

**Feature Access Flow:**
1. Frontend loads user profile (`GET /api/user/profile`)
2. Profile includes `subscriptionTier` and `features` object
3. Components conditionally render based on `features.allowAdvancedAudioControls`
4. For FREE/BASIC: show preset selector only, lock audio sliders
5. For PREMIUM: show all audio sliders and advanced controls
6. Middleware validates tier on backend for all protected operations

**Recording Usage Flow:**
1. User attempts to generate TTS
2. Frontend checks usage: `GET /api/user/usage` → `{ recordingsUsed: 9, recordingsLimit: 10 }`
3. If at limit (non-Premium): show upgrade modal instead
4. If under limit: call `POST /api/tts`
5. Backend validates session and checks tier limits
6. If at limit: return 403 with `{ error: 'LIMIT_REACHED', upgradeUrl }`
7. If under limit: generate TTS, increment `recordingsThisMonth` in DynamoDB
8. Return audio blob

**Load Balancing and Scaling:**
- AWS Amplify handles load balancing automatically
- Horizontal scaling based on incoming traffic
- Stateless application servers (session in Redis)
- Redis cluster handles session lookups across all instances
- DynamoDB auto-scales read/write capacity
- S3 handles unlimited concurrent requests

**Data Lifecycle:**
- Favorited recordings: permanent storage in S3
- Non-favorited recordings: 7-day retention, then Glacier, then delete after 30 days
- Sessions: auto-expire after 15 minutes via Redis TTL and DynamoDB TTL
- User data: retained indefinitely (or implement GDPR deletion flow)
- Subscription data: retained for audit/compliance

## Package Dependencies to Add

```json
{
  "@aws-sdk/client-dynamodb": "^3.x",
  "@aws-sdk/lib-dynamodb": "^3.x",
  "@aws-sdk/client-s3": "^3.x",
  "@aws-sdk/s3-request-presigner": "^3.x",
  "@auth0/nextjs-auth0": "^3.x",
  "stripe": "^14.x",
  "ioredis": "^5.x",
  "uuid": "^9.x"
}
```

